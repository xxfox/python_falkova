"""
3. Есть два файла: в одном хранятся ФИО пользователей сайта, а в другом — данные об их хобби. 
Известно, что при хранении данных используется принцип: одна строка — один пользователь, разделитель 
между значениями — запятая. Написать код, загружающий данные из обоих файлов и формирующий из них словарь: 
ключи — ФИО, значения — данные о хобби. Сохранить словарь в файл. Проверить сохранённые данные. 
Если в файле, хранящем данные о хобби, меньше записей, чем в файле с ФИО, задаём в словаре значение None. 
Если наоборот — выходим из скрипта с кодом «1». При решении задачи считать, что объём данных в файлах во много 
раз меньше объема ОЗУ.
4. * (вместо 3) Решить задачу 3 для ситуации, когда объём данных в файлах превышает объём ОЗУ
\(разумеется, не нужно реально создавать такие большие файлы, это просто задел на будущее проекта). 
Также реализовать парсинг данных из файлов - получить отдельно фамилию, имя и отчество для пользователей и 
название каждого хобби: преобразовать в какой-нибудь контейнерный тип (список, кортеж, множество, словарь). 
Обосновать выбор типа. Подумать, какие могут возникнуть проблемы при парсинге. В словаре должны храниться данные, 
полученные в результате парсинга.
5. ** (вместо 4) Решить задачу 4 и реализовать интерфейс командной строки, чтобы можно было задать путь к обоим 
исходным файлам и путь к выходному файлу со словарём. Проверить работу скрипта для случая, когда все файлы находятся 
в разных папках.
6. Реализовать простую систему хранения данных о суммах продаж булочной. Должно быть два скрипта с интерфейсом 
командной строки: для записи данных и для вывода на экран записанных данных. При записи передавать из командной 
строки значение суммы продаж. 
7. Подумать, как избежать чтения всего файла при реализации второго и третьего случаев.
Данные хранить в файле bakery.csv в кодировке utf-8. Нумерация записей начинается с 1. 
7. * (вместо 6) Добавить возможность редактирования данных при помощи отдельного скрипта: передаём ему номер записи 
и новое значение. При этом файл не должен читаться целиком — обязательное требование. 
Предусмотреть ситуацию, когда пользователь вводит номер записи, которой не существует.
"""

import csv
from itertools import zip_longest

file_1 = input('Введите имя файла с именами: ') #users.csv
file_2 = input('Введите имя файла с хобби: ') #hobby.csv
file_3 = input('Введите имя файла для записи: ')

with open(file_1, 'r', encoding='utf-8') as u, open(file_2, 'r', encoding='utf-8') as h, open(file_3, 'a', encoding='utf-8') as f:
    user_reader = csv.reader(u, delimiter=',')
    hobby_reader = csv.reader(h, delimiter=',')
    for row_1, row_2 in zip_longest(user_reader, hobby_reader):
        if row_1 is None:
            exit(1)
        elif row_2 is None:
            b = 'None'
        else:
            b = ', '.join(list(row_2))
        a = ' '.join(list(row_1))
        f.write(f'{a}: {b} \n')


def add_data(num):
    with open('bakery.csv', 'a', encoding='utf-8') as add:
        add.write(f'{num} \n')
        print(f'Сумма {num} добавлена')


if __name__ == '__main__':
    import sys

    add_data(sys.argv[1])


import csv


def show_proseed(start=0, end=0):
    start = int(start)
    end = int(end)
    with open('bakery.csv', 'r', encoding='utf-8') as f:
        proceeds = csv.reader(f)
        for row in proceeds:
            if end > 0:
                if proceeds.line_num >= start and proceeds.line_num <= end:
                    print(''.join(row))
            elif proceeds.line_num > start:
                print(''.join(row))
            elif start == 0 and end == 0:
                print(''.join(row))


if __name__ == '__main__':
    import sys
    show_proseed(*sys.argv[1:])

def update_data(position, new_sum):
    position = int(input('Введите номер изменяемой строки: '))
    new_sum = input('Введите новую сумму выручки: ')
    position = int(position)
    lins = open('bakery.csv', 'r').readlines()
    lins[position - 1] = f'{new_sum} \n'
    out = open('bakery.csv', 'w')
    out.writelines(lins)
    out.close()


if __name__ == '__main__':
    import sys
    update_data(*sys.argv[1:])

